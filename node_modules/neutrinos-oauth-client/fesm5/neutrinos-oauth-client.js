import { __awaiter, __generator } from 'tslib';
import { isDevMode, Injectable, ɵɵdefineInjectable, ɵɵinject, Component, NgModule, APP_INITIALIZER } from '@angular/core';
import { HttpHeaders, HttpClient, HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { Subject, throwError } from 'rxjs';
import { Router, ActivatedRoute } from '@angular/router';
import { map, catchError } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/util.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var UtilService = /** @class */ (function () {
    function UtilService() {
        this.platformType = this.checkPlatformType();
        this.getEnvironment();
    }
    /**
     * Returns 'mobile' or 'browser' based on the platform
     */
    /**
     * Returns 'mobile' or 'browser' based on the platform
     * @return {?}
     */
    UtilService.prototype.getPlatformType = /**
     * Returns 'mobile' or 'browser' based on the platform
     * @return {?}
     */
    function () {
        return this.platformType;
    };
    /**
     * Returns env from neutrinos seed app
     */
    /**
     * Returns env from neutrinos seed app
     * @private
     * @return {?}
     */
    UtilService.prototype.getEnvironment = /**
     * Returns env from neutrinos seed app
     * @private
     * @return {?}
     */
    function () {
        if (window['neutrinos'] && window['neutrinos']['environments'] && window['neutrinos']['environments']['properties']) {
            // Break the refernce
            this.environment = JSON.parse(JSON.stringify(window['neutrinos']['environments']['properties']));
            // Append the url with / if ssdUrl does not end with /
            if (this.environment['ssdURL']) {
                this.environment['ssdURL'] = this.environment['ssdURL'].endsWith('/') ? this.environment['ssdURL'] :
                    (this.environment['ssdURL'] + '/');
            }
            return;
        }
        /*For dev env only */
        this.environment = {
            ssdURL: 'http://localhost:8081/api/',
            useDefaultExceptionUI: true,
            isIDSEnabled: false,
            webAppMountpoint: '',
            production: true
        };
    };
    /**
     * Returns 'mobile' or 'browser' based on the platform
     */
    /**
     * Returns 'mobile' or 'browser' based on the platform
     * @private
     * @return {?}
     */
    UtilService.prototype.checkPlatformType = /**
     * Returns 'mobile' or 'browser' based on the platform
     * @private
     * @return {?}
     */
    function () {
        // tslint:disable-next-line: no-string-literal
        if (window['device'] && (window['device']['platform'] !== 'browser' || window['device']['platform'] !== 'Browser')) {
            return 'mobile';
            // tslint:disable-next-line: no-string-literal
        }
        else if (window['device'] && (window['device']['platform'] === 'browser' || window['device']['platform'] === 'Browser')) {
            return 'cordova_browser';
        }
        else {
            return 'browser';
        }
    };
    /*URL helper methods */
    /*URL helper methods */
    /**
     * @return {?}
     */
    UtilService.prototype.getBaseLoginPath = /*URL helper methods */
    /**
     * @return {?}
     */
    function () {
        return this.environment.ssdURL + "login";
    };
    /**
     * @param {?} redirectTo
     * @return {?}
     */
    UtilService.prototype.getWebLoginUrl = /**
     * @param {?} redirectTo
     * @return {?}
     */
    function (redirectTo) {
        redirectTo = this.calcRedirectUrl(redirectTo);
        return this.getBaseLoginPath() + "?redirectTo=" + redirectTo;
    };
    /**
     * @return {?}
     */
    UtilService.prototype.getMobileLoginUrl = /**
     * @return {?}
     */
    function () {
        return this.getBaseLoginPath() + "?isMobile=true";
    };
    /**
     * @param {?} redirectTo
     * @return {?}
     */
    UtilService.prototype.getWebLogoutUrl = /**
     * @param {?} redirectTo
     * @return {?}
     */
    function (redirectTo) {
        redirectTo = this.calcRedirectUrl(redirectTo);
        return this.environment.ssdURL + "logout?redirectTo=" + redirectTo;
    };
    /**
     * @return {?}
     */
    UtilService.prototype.getMobileLogoutUrl = /**
     * @return {?}
     */
    function () {
        return this.environment.ssdURL + "logout?isMobile=true";
    };
    /**
     * @return {?}
     */
    UtilService.prototype.getUserInfoUrl = /**
     * @return {?}
     */
    function () {
        return this.environment.ssdURL + "user/info";
    };
    /**
     * @return {?}
     */
    UtilService.prototype.getSSDBasePath = /**
     * @return {?}
     */
    function () {
        return "" + this.environment.ssdURL;
    };
    /**
     *  Returns a absoulte url for the urlPath
     * @param urlPath - path relative to the current host
     */
    /**
     *  Returns a absoulte url for the urlPath
     * @private
     * @param {?} urlPath - path relative to the current host
     * @return {?}
     */
    UtilService.prototype.calcRedirectUrl = /**
     *  Returns a absoulte url for the urlPath
     * @private
     * @param {?} urlPath - path relative to the current host
     * @return {?}
     */
    function (urlPath) {
        if (urlPath) {
            /** @type {?} */
            var host = new URL(window.location.href).origin;
            if (!isDevMode()) {
                // Append `webAppMountpoint` to host
                host = (this.environment.webAppMountpoint !== '' && this.environment.webAppMountpoint !== '/')
                    ? new URL(this.environment.webAppMountpoint, host).href : host;
                // Get user redirect path with `webAppMountpoint`
                /** @type {?} */
                var mountPointWithRedirect = new URL(urlPath, host).pathname;
                return host + mountPointWithRedirect;
            }
            else {
                return new URL(urlPath, host);
            }
        }
        else {
            return window.location.href;
        }
    };
    /**
     *
     * @param property - environment property key
     */
    /**
     *
     * @param {?} property - environment property key
     * @return {?}
     */
    UtilService.prototype.getEnvValue = /**
     *
     * @param {?} property - environment property key
     * @return {?}
     */
    function (property) {
        return this.environment[property];
    };
    UtilService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    UtilService.ctorParameters = function () { return []; };
    /** @nocollapse */ UtilService.ɵprov = ɵɵdefineInjectable({ factory: function UtilService_Factory() { return new UtilService(); }, token: UtilService, providedIn: "root" });
    return UtilService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    UtilService.prototype.platformType;
    /**
     * @type {?}
     * @private
     */
    UtilService.prototype.environment;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/neutrinos-oauth-client.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NeutrinosOAuthClientService = /** @class */ (function () {
    function NeutrinosOAuthClientService(util, http) {
        this.util = util;
        this.http = http;
        this.cookieName = 'connect.sid';
        this.authStateSubject = new Subject();
    }
    Object.defineProperty(NeutrinosOAuthClientService.prototype, "userInfo", {
        /**
         * Get user info and tokens of the current logged in user
         */
        get: /**
         * Get user info and tokens of the current logged in user
         * @return {?}
         */
        function () {
            return this.currentUserInfo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NeutrinosOAuthClientService.prototype, "isLoggedIn", {
        get: /**
         * @return {?}
         */
        function () {
            return this.currentUserInfo ? true : false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} userInfo
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.setUserInfo = /**
     * @private
     * @param {?} userInfo
     * @return {?}
     */
    function (userInfo) {
        this.currentUserInfo = userInfo;
    };
    /**
     * Performs authentication based on configuration and returns user info for mobile env and
     * for web app user info is stored in memory. Call userInfo getter method to retrieve userinfo
     * @param redirectBackUrl - url to redirect back to when authentication is done. Valid only for Web.
     * For mobile use the Promise returned to perform post authentication actions
     */
    /**
     * Performs authentication based on configuration and returns user info for mobile env and
     * for web app user info is stored in memory. Call userInfo getter method to retrieve userinfo
     * @param {?=} redirectBackUrl - url to redirect back to when authentication is done. Valid only for Web.
     * For mobile use the Promise returned to perform post authentication actions
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.login = /**
     * Performs authentication based on configuration and returns user info for mobile env and
     * for web app user info is stored in memory. Call userInfo getter method to retrieve userinfo
     * @param {?=} redirectBackUrl - url to redirect back to when authentication is done. Valid only for Web.
     * For mobile use the Promise returned to perform post authentication actions
     * @return {?}
     */
    function (redirectBackUrl) {
        var _this = this;
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        function (resolve, reject) {
            if (_this.util.getEnvValue('isIDSEnabled') === 'false') {
                return reject({ message: 'IDS is not enabled in environments' });
            }
            if (_this.util.getPlatformType() === 'browser') {
                _this.loginWithRedirect(redirectBackUrl);
                return;
            }
            _this.loginWithInAppBrowser()
                .then((/**
             * @param {?} tokenset
             * @return {?}
             */
            function (tokenset) {
                return resolve(tokenset);
            }))
                .catch((/**
             * @param {?} authError
             * @return {?}
             */
            function (authError) {
                return reject(authError);
            }));
        }));
    };
    /**
     *
     * @param loginUrl - Login url where SSD is hosted
     */
    /**
     *
     * @private
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.loginWithInAppBrowser = /**
     *
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            var scriptURLS, script, inAppBrowserRef, executeScriptCB, exitCB;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        scriptURLS = ['/interaction/', '/auth-provider/return'];
                        // execute JS only for this urls
                        return [4 /*yield*/, this.getScript()];
                    case 1:
                        script = _a.sent();
                        // Get JS which stores guid and device details in local storage of webview
                        inAppBrowserRef = cordova.InAppBrowser.open(this.util.getMobileLoginUrl(), '_blank');
                        executeScriptCB = (/**
                         * @param {?} event
                         * @return {?}
                         */
                        function (event) {
                            if (event && event.hasOwnProperty('type') && event.hasOwnProperty('url') && event.type === 'loadstop'
                                && _this.isURLMatch(event.url, scriptURLS)) {
                                inAppBrowserRef.executeScript({ code: script }, (/**
                                 * @return {?}
                                 */
                                function () { }));
                            }
                        });
                        inAppBrowserRef.addEventListener('loadstop', executeScriptCB);
                        exitCB = (/**
                         * @return {?}
                         */
                        function () {
                            return reject({ code: 'auth-cancel', message: 'Authentication cancelled by user' });
                        });
                        inAppBrowserRef.addEventListener('message', (/**
                         * @param {?} message
                         * @return {?}
                         */
                        function (message) {
                            if (message && message.data && message.data.auth && message.data.auth === 'success') {
                                inAppBrowserRef.removeEventListener('exit', exitCB);
                                inAppBrowserRef.close();
                                _this.persistCookies();
                                _this.getUserInfo().then((/**
                                 * @param {?} tokenset
                                 * @return {?}
                                 */
                                function (tokenset) {
                                    return resolve(tokenset);
                                })).catch((/**
                                 * @param {?} authErr
                                 * @return {?}
                                 */
                                function (authErr) {
                                    return reject(authErr);
                                }));
                            }
                        }));
                        // settle the promise if user closed the in app browser manually
                        inAppBrowserRef.addEventListener('exit', exitCB);
                        return [2 /*return*/];
                }
            });
        }); }));
    };
    /**
     * @private
     * @param {?} url
     * @param {?} compareWith
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.isURLMatch = /**
     * @private
     * @param {?} url
     * @param {?} compareWith
     * @return {?}
     */
    function (url, compareWith) {
        return compareWith.some((/**
         * @param {?} u
         * @return {?}
         */
        function (u) { return url.includes(u); }));
    };
    /**
     * Returns JS as a string to be executed in inAppBrowser which sets guid and device details in localStorage
     */
    /**
     * Returns JS as a string to be executed in inAppBrowser which sets guid and device details in localStorage
     * @private
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.getScript = /**
     * Returns JS as a string to be executed in inAppBrowser which sets guid and device details in localStorage
     * @private
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var deviceDetails, guid, guidScript, script;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        deviceDetails = JSON.stringify(window['device']) || {};
                        return [4 /*yield*/, this.getuniqueDeviceID()];
                    case 1:
                        guid = _a.sent();
                        guidScript = guid ? "localStorage.setItem('guid', '" + guid + "')" : '';
                        script = guidScript + "\n          localStorage.setItem('additionalInfo', '" + deviceDetails + "')\n          window.isScriptExecuted = true;";
                        return [2 /*return*/, script];
                }
            });
        });
    };
    /**
     * @private
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.getuniqueDeviceID = /**
     * @private
     * @return {?}
     */
    function () {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        function (resolve, reject) {
            window['plugins'].uniqueDeviceID.get((/**
             * @param {?} guid
             * @return {?}
             */
            function (guid) {
                return resolve(guid);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                return resolve(null);
            }));
        }));
    };
    /**
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.getUserInfo = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        function (resolve, reject) {
            /** @type {?} */
            var headers = new HttpHeaders();
            /*Edge case: Userinfo is retreived from cache when login page is opened and user cancels the login attempt  */
            headers = headers.set('Cache-Control', 'no-cache');
            headers = headers.set('Pragma', 'no-cache');
            _this.http.get(_this.util.getUserInfoUrl(), { headers: headers }).subscribe((/**
             * @param {?} tokenset
             * @return {?}
             */
            function (tokenset) {
                _this.setUserInfo(tokenset);
                return resolve(tokenset);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                _this.destroyClientSession();
                return reject(error);
            }));
        }));
    };
    /*If SSD throws 401 during any http request due to refresh token expiry, cookie expiry or access revoke nullify the userinfo in memory
    and emit authState event  */
    /*If SSD throws 401 during any http request due to refresh token expiry, cookie expiry or access revoke nullify the userinfo in memory
      and emit authState event  */
    /**
     * @param {?} errorResponse
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.removeUserInfo = /*If SSD throws 401 during any http request due to refresh token expiry, cookie expiry or access revoke nullify the userinfo in memory
      and emit authState event  */
    /**
     * @param {?} errorResponse
     * @return {?}
     */
    function (errorResponse) {
        this.destroyClientSession();
        this.authStateSubject.next(errorResponse);
    };
    /**
     * Returns event when Auth state has changed due to session expiry, access revoke or cookie expiry.
     */
    /**
     * Returns event when Auth state has changed due to session expiry, access revoke or cookie expiry.
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.authState = /**
     * Returns event when Auth state has changed due to session expiry, access revoke or cookie expiry.
     * @return {?}
     */
    function () {
        return this.authStateSubject.asObservable();
    };
    /**
     * @private
     * @param {?} redirectBackUrl
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.loginWithRedirect = /**
     * @private
     * @param {?} redirectBackUrl
     * @return {?}
     */
    function (redirectBackUrl) {
        window.location.href = this.util.getWebLoginUrl(redirectBackUrl);
    };
    /**
     * Persists cookies in localStorage to be used during next app launch only for IOS
     */
    /**
     * Persists cookies in localStorage to be used during next app launch only for IOS
     * @private
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.persistCookies = /**
     * Persists cookies in localStorage to be used during next app launch only for IOS
     * @private
     * @return {?}
     */
    function () {
        if (window['device'] && window['device'].platform === 'iOS') {
            this.getCookie(this.cookieName, this.util.getSSDBasePath())
                .then((/**
             * @param {?} connectSid
             * @return {?}
             */
            function (connectSid) {
                localStorage.setItem('connectSid', connectSid);
            }));
        }
    };
    /**
     * Restores the connect.sid cookie from session storage during app bootstrap if device is mobile
     */
    /**
     * Restores the connect.sid cookie from session storage during app bootstrap if device is mobile
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.restoreCookies = /**
     * Restores the connect.sid cookie from session storage during app bootstrap if device is mobile
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var connectSidCookie;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        connectSidCookie = localStorage.getItem('connectSid');
                        if (!connectSidCookie) {
                            return [2 /*return*/, false];
                        }
                        return [4 /*yield*/, this.setCookie(this.util.getSSDBasePath(), this.cookieName, connectSidCookie)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     *
     * @param url - site where the cookie is stored
     * @param cookieName - name of the cookie to restore
     * @param cookieValue - value of the cookie to restore
     */
    /**
     *
     * @private
     * @param {?} url - site where the cookie is stored
     * @param {?} cookieName - name of the cookie to restore
     * @param {?} cookieValue - value of the cookie to restore
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.setCookie = /**
     *
     * @private
     * @param {?} url - site where the cookie is stored
     * @param {?} cookieName - name of the cookie to restore
     * @param {?} cookieValue - value of the cookie to restore
     * @return {?}
     */
    function (url, cookieName, cookieValue) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        function (resolve, reject) {
            cookieMaster.setCookieValue(url, cookieName, cookieValue, (/**
             * @return {?}
             */
            function () {
                return resolve(true);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                return reject(error);
            }));
        }));
    };
    /**
     *
     * @param  cookieName - name of the cookie to retrieve
     * @param   url - site where the cookie is stored
     */
    /**
     *
     * @private
     * @param {?} cookieName - name of the cookie to retrieve
     * @param {?} url - site where the cookie is stored
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.getCookie = /**
     *
     * @private
     * @param {?} cookieName - name of the cookie to retrieve
     * @param {?} url - site where the cookie is stored
     * @return {?}
     */
    function (cookieName, url) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        function (resolve, reject) {
            cookieMaster.getCookieValue(url, cookieName, (/**
             * @param {?} cookie
             * @return {?}
             */
            function (cookie) {
                return resolve(cookie.cookieValue);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                return reject(error);
            }));
        }));
    };
    /**
     * Logout the current user, destroys session between client and server.
     * @param redirectBackUrl - URL where the user is navigated post logout. Valid only for Web.
     * For mobile use the Promise returned to perform post authentication actions
     */
    /**
     * Logout the current user, destroys session between client and server.
     * @param {?=} redirectBackUrl - URL where the user is navigated post logout. Valid only for Web.
     * For mobile use the Promise returned to perform post authentication actions
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.logout = /**
     * Logout the current user, destroys session between client and server.
     * @param {?=} redirectBackUrl - URL where the user is navigated post logout. Valid only for Web.
     * For mobile use the Promise returned to perform post authentication actions
     * @return {?}
     */
    function (redirectBackUrl) {
        var _this = this;
        /** @type {?} */
        var logoutUrl = (this.util.getPlatformType() === 'browser') ? this.util.getWebLogoutUrl(redirectBackUrl)
            : this.util.getMobileLogoutUrl();
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        function (resolve, reject) {
            _this.http.get(logoutUrl).subscribe((/**
             * @param {?} idsLogoutInfo
             * @return {?}
             */
            function (idsLogoutInfo) {
                _this.destroyIDSSession(idsLogoutInfo)
                    .then((/**
                 * @return {?}
                 */
                function () {
                    return resolve();
                }))
                    .catch((/**
                 * @param {?} logoutErr
                 * @return {?}
                 */
                function (logoutErr) {
                    return reject(logoutErr);
                }));
            }), (/**
             * @param {?} logoutError
             * @return {?}
             */
            function (logoutError) {
                return reject(logoutError);
            }));
        }));
    };
    /**
     * @private
     * @param {?} idsInfo
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.destroyIDSSession = /**
     * @private
     * @param {?} idsInfo
     * @return {?}
     */
    function (idsInfo) {
        var _this = this;
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        function (resolve, reject) {
            if (idsInfo['sessionExists'] === false) {
                // No session present with SSD due to cookie expiry
                _this.destroyClientSession();
                _this.authStateSubject.next({ code: 'NO_SESSION', message: 'User session has already expired' });
                return resolve();
            }
            if (_this.util.getPlatformType() === 'browser') {
                window.location.href = idsInfo['idsURL'];
            }
            else {
                _this.logoutWithInappBrowser(idsInfo['idsURL'])
                    .then((/**
                 * @return {?}
                 */
                function () {
                    return resolve();
                }))
                    .catch((/**
                 * @param {?} sessionError
                 * @return {?}
                 */
                function (sessionError) {
                    return reject(sessionError);
                }));
            }
        }));
    };
    /**
     *
     * @param idsLogoutUrl - IDS logout url
     * Opens InApp browser and destroys the session
     */
    /**
     *
     * @private
     * @param {?} idsLogoutUrl - IDS logout url
     * Opens InApp browser and destroys the session
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.logoutWithInappBrowser = /**
     *
     * @private
     * @param {?} idsLogoutUrl - IDS logout url
     * Opens InApp browser and destroys the session
     * @return {?}
     */
    function (idsLogoutUrl) {
        var _this = this;
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        function (resolve, reject) {
            /** @type {?} */
            var exitCB = (/**
             * @return {?}
             */
            function () {
                return reject({ code: 'auth-cancel', message: 'Authentication cancelled by user' });
            });
            /** @type {?} */
            var inAppBrowserRef = cordova.InAppBrowser.open(idsLogoutUrl, '_blank');
            inAppBrowserRef.addEventListener('message', (/**
             * @param {?} message
             * @return {?}
             */
            function (message) {
                // Remove exit listener if script closed the in app browser
                if (message && message.data && message.data.auth && message.data.auth === 'success') {
                    inAppBrowserRef.removeEventListener('exit', exitCB);
                    inAppBrowserRef.close();
                    _this.destroyClientSession();
                    return resolve();
                }
            }));
            // settle the promise if user closed the in app browser manually
            inAppBrowserRef.addEventListener('exit', exitCB);
        }));
    };
    /*Remove persisted cookies in local storage and nullify user info */
    /*Remove persisted cookies in local storage and nullify user info */
    /**
     * @private
     * @return {?}
     */
    NeutrinosOAuthClientService.prototype.destroyClientSession = /*Remove persisted cookies in local storage and nullify user info */
    /**
     * @private
     * @return {?}
     */
    function () {
        this.setUserInfo(null);
        window.localStorage.removeItem('connectSid');
    };
    NeutrinosOAuthClientService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    NeutrinosOAuthClientService.ctorParameters = function () { return [
        { type: UtilService },
        { type: HttpClient }
    ]; };
    /** @nocollapse */ NeutrinosOAuthClientService.ɵprov = ɵɵdefineInjectable({ factory: function NeutrinosOAuthClientService_Factory() { return new NeutrinosOAuthClientService(ɵɵinject(UtilService), ɵɵinject(HttpClient)); }, token: NeutrinosOAuthClientService, providedIn: "root" });
    return NeutrinosOAuthClientService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NeutrinosOAuthClientService.prototype.cookieName;
    /**
     * @type {?}
     * @private
     */
    NeutrinosOAuthClientService.prototype.currentUserInfo;
    /**
     * @type {?}
     * @private
     */
    NeutrinosOAuthClientService.prototype.authStateSubject;
    /**
     * @type {?}
     * @private
     */
    NeutrinosOAuthClientService.prototype.util;
    /**
     * @type {?}
     * @private
     */
    NeutrinosOAuthClientService.prototype.http;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/auth-guard.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NeutrinosAuthGuardService = /** @class */ (function () {
    function NeutrinosAuthGuardService(_neutrinosOAuthClientService, _router, _arouter) {
        this._neutrinosOAuthClientService = _neutrinosOAuthClientService;
        this._router = _router;
        this._arouter = _arouter;
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    NeutrinosAuthGuardService.prototype.canActivate = /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    function (route, state) {
        var _this = this;
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        function (resolve, reject) {
            _this.currUrl = state.url;
            if (_this._neutrinosOAuthClientService.isLoggedIn) {
                return resolve(true);
            }
            else {
                _this._neutrinosOAuthClientService.login().then((/**
                 * @param {?} tokenSet
                 * @return {?}
                 */
                function (tokenSet) {
                    _this._router.navigate([_this.currUrl]);
                    return resolve(true);
                }))
                    .catch((/**
                 * @param {?} err
                 * @return {?}
                 */
                function (err) {
                    console.error(err);
                    if (err && err.code == 'auth-cancel') {
                        // Added setTimeout for reloading the current route
                        setTimeout((/**
                         * @return {?}
                         */
                        function () {
                            _this._router.navigateByUrl(_this.currUrl, { skipLocationChange: true }).then((/**
                             * @return {?}
                             */
                            function () {
                                return resolve(false);
                            }));
                        }), 500);
                    }
                    else {
                        return resolve(false);
                    }
                }));
            }
        }));
    };
    NeutrinosAuthGuardService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    NeutrinosAuthGuardService.ctorParameters = function () { return [
        { type: NeutrinosOAuthClientService },
        { type: Router },
        { type: ActivatedRoute }
    ]; };
    /** @nocollapse */ NeutrinosAuthGuardService.ɵprov = ɵɵdefineInjectable({ factory: function NeutrinosAuthGuardService_Factory() { return new NeutrinosAuthGuardService(ɵɵinject(NeutrinosOAuthClientService), ɵɵinject(Router), ɵɵinject(ActivatedRoute)); }, token: NeutrinosAuthGuardService, providedIn: "root" });
    return NeutrinosAuthGuardService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NeutrinosAuthGuardService.prototype.currUrl;
    /**
     * @type {?}
     * @private
     */
    NeutrinosAuthGuardService.prototype._neutrinosOAuthClientService;
    /**
     * @type {?}
     * @private
     */
    NeutrinosAuthGuardService.prototype._router;
    /**
     * @type {?}
     * @private
     */
    NeutrinosAuthGuardService.prototype._arouter;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/neutrinos-oauth.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NeutrinosOauthComponent = /** @class */ (function () {
    function NeutrinosOauthComponent(neutrinosOauthService, http) {
        this.neutrinosOauthService = neutrinosOauthService;
        this.http = http;
    }
    /**
     * @return {?}
     */
    NeutrinosOauthComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.neutrinosOauthService.authState().subscribe((/**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            console.log(state);
        }));
    };
    /**
     * @return {?}
     */
    NeutrinosOauthComponent.prototype.login = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var a = this.neutrinosOauthService.login('/i-am-loggedin').then((/**
         * @param {?} tokens
         * @return {?}
         */
        function (tokens) {
            console.log('got tokens in component', tokens);
        })).catch((/**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            console.error(e);
        }));
        // console.log(a);
    };
    /**
     * @return {?}
     */
    NeutrinosOauthComponent.prototype.token = /**
     * @return {?}
     */
    function () {
        this.neutrinosOauthService.getUserInfo().then((/**
         * @param {?} t
         * @return {?}
         */
        function (t) {
            console.log('t', t);
        })).catch(console.log);
    };
    /**
     * @return {?}
     */
    NeutrinosOauthComponent.prototype.logout = /**
     * @return {?}
     */
    function () {
        this.neutrinosOauthService.logout();
    };
    /**
     * @return {?}
     */
    NeutrinosOauthComponent.prototype.userinfo = /**
     * @return {?}
     */
    function () {
        alert(JSON.stringify(this.neutrinosOauthService.userInfo));
        console.log(this.neutrinosOauthService.userInfo);
    };
    /**
     * @return {?}
     */
    NeutrinosOauthComponent.prototype.httpTest = /**
     * @return {?}
     */
    function () {
        this.http.get('http://localhost:8081/api/ping').subscribe((/**
         * @param {?} res
         * @return {?}
         */
        function (res) {
            console.log(res);
        }), (/**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            console.error(e);
        }));
    };
    NeutrinosOauthComponent.decorators = [
        { type: Component, args: [{
                    selector: 'lib-neutrinos-oauth',
                    template: "\n   NOTE: use this component only for testing. Not intended for production\n\n      <button (click)=\"login()\" >  Login </button>\n      <button (click)=\"token()\" > Get tokenset</button>\n      <button (click)=\"logout()\" > Logout </button>\n      <button (click)=\"userinfo()\" > In memory user info </button>\n      <button (click)=\"httpTest()\" > Http Interceptor test </button>\n      "
                }] }
    ];
    /** @nocollapse */
    NeutrinosOauthComponent.ctorParameters = function () { return [
        { type: NeutrinosOAuthClientService },
        { type: HttpClient }
    ]; };
    return NeutrinosOauthComponent;
}());
if (false) {
    /** @type {?} */
    NeutrinosOauthComponent.prototype.neutrinosOauthService;
    /**
     * @type {?}
     * @private
     */
    NeutrinosOauthComponent.prototype.http;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/cookie-interceptor.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CookieInterceptorService = /** @class */ (function () {
    function CookieInterceptorService(utilService, neutrinosOAuthClientService) {
        this.utilService = utilService;
        this.neutrinosOAuthClientService = neutrinosOAuthClientService;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    CookieInterceptorService.prototype.intercept = /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    function (request, next) {
        var _this = this;
        /* withCredentials adds cookies to the request for cross site (Only ssd urls).*/
        /** @type {?} */
        var baseUrl = this.utilService.getSSDBasePath();
        /** @type {?} */
        var isSSD = (baseUrl !== '' && request.url.includes(baseUrl));
        if (isSSD && this.isCrossDomain(baseUrl)) {
            request = request.clone({
                withCredentials: true
            });
        }
        return next.handle(request).pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            return event;
        })), catchError((/**
         * @param {?} errorResponse
         * @return {?}
         */
        function (errorResponse) {
            /*Intercept all requests and remove userinfo and cookies when status is 401 with code SESSION_EXPIRED, which means
            * cookies have expired or access has been revoked by the OAuth providers hence IDS rejected.  */
            if (errorResponse && errorResponse.hasOwnProperty('status') && errorResponse.status === 401 &&
                errorResponse.error.hasOwnProperty('code')) {
                _this.neutrinosOAuthClientService.removeUserInfo(errorResponse.error);
            }
            return throwError(errorResponse);
        })));
    };
    /**
     * Returns true is the ssd url is running on a different domain than where UI is hosted.
     * For mobile Returns false always since UI is already bundled with cordova
     * If the user is not using IDS and is cross domain isIDSEnabled can be set to false to skip adding withCredentials
     * @param ssdUrl - string
     */
    /**
     * Returns true is the ssd url is running on a different domain than where UI is hosted.
     * For mobile Returns false always since UI is already bundled with cordova
     * If the user is not using IDS and is cross domain isIDSEnabled can be set to false to skip adding withCredentials
     * @private
     * @param {?} ssdUrl - string
     * @return {?}
     */
    CookieInterceptorService.prototype.isCrossDomain = /**
     * Returns true is the ssd url is running on a different domain than where UI is hosted.
     * For mobile Returns false always since UI is already bundled with cordova
     * If the user is not using IDS and is cross domain isIDSEnabled can be set to false to skip adding withCredentials
     * @private
     * @param {?} ssdUrl - string
     * @return {?}
     */
    function (ssdUrl) {
        try {
            ssdUrl = new URL(ssdUrl);
            return (this.utilService.getPlatformType() === 'browser' && (ssdUrl.host !== location.host)
                && this.utilService.getEnvValue('isIDSEnabled') === 'true');
        }
        catch (e) {
            console.error(e);
        }
    };
    CookieInterceptorService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    CookieInterceptorService.ctorParameters = function () { return [
        { type: UtilService },
        { type: NeutrinosOAuthClientService }
    ]; };
    /** @nocollapse */ CookieInterceptorService.ɵprov = ɵɵdefineInjectable({ factory: function CookieInterceptorService_Factory() { return new CookieInterceptorService(ɵɵinject(UtilService), ɵɵinject(NeutrinosOAuthClientService)); }, token: CookieInterceptorService, providedIn: "root" });
    return CookieInterceptorService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    CookieInterceptorService.prototype.utilService;
    /**
     * @type {?}
     * @private
     */
    CookieInterceptorService.prototype.neutrinosOAuthClientService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/neutrinos-oauth-client.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} neutrinosOAuthService
 * @param {?} utilService
 * @return {?}
 */
function getTokens(neutrinosOAuthService, utilService) {
    return (/**
     * @return {?}
     */
    function () {
        /**
         * For ios restore the cookies and get userInfo since iOS webview does not
         * persisit the cookie between app launches
         */
        if (utilService.getEnvValue('isIDSEnabled') === 'true') {
            if (window['device'] && window['device'].platform === 'iOS') {
                return neutrinosOAuthService.restoreCookies().then((/**
                 * @param {?} cookieExist
                 * @return {?}
                 */
                function (cookieExist) {
                    console.log('cookieExist' + cookieExist);
                    cookieExist ? neutrinosOAuthService.getUserInfo()
                        .catch((/**
                     * @param {?} userInfoErr
                     * @return {?}
                     */
                    function (userInfoErr) {
                        console.log(userInfoErr);
                    })) : null;
                }));
            }
            else {
                // Cannot get cookie for cross domain using JS. hence calling userinfo always
                return neutrinosOAuthService.getUserInfo()
                    .catch((/**
                 * @param {?} userInfoErr
                 * @return {?}
                 */
                function (userInfoErr) {
                    console.log(userInfoErr);
                }));
            }
        }
    });
}
// @dynamic (https://github.com/ng-packagr/ng-packagr/issues/641)
var NeutrinosOAuthClientModule = /** @class */ (function () {
    function NeutrinosOAuthClientModule() {
    }
    NeutrinosOAuthClientModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [NeutrinosOauthComponent],
                    imports: [
                        HttpClientModule
                    ],
                    providers: [
                        {
                            provide: HTTP_INTERCEPTORS,
                            useClass: CookieInterceptorService,
                            multi: true
                        },
                        {
                            provide: APP_INITIALIZER,
                            useFactory: getTokens,
                            deps: [NeutrinosOAuthClientService, UtilService],
                            multi: true
                        },
                    ]
                },] }
    ];
    return NeutrinosOAuthClientModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: neutrinos-oauth-client.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NeutrinosAuthGuardService, NeutrinosOAuthClientModule, NeutrinosOAuthClientService, getTokens, UtilService as ɵa, NeutrinosOauthComponent as ɵb, CookieInterceptorService as ɵc };
//# sourceMappingURL=neutrinos-oauth-client.js.map
